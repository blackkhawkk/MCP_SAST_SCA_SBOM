import { execa } from "execa";
import { existsSync, readFile } from "fs-extra";
import path from "path";

export type ScanType = "sca" | "sast" | "secrets" | "iac" | "container";

export interface VulnerabilityResult {
  id: string;
  title: string;
  description: string;
  severity: "critical" | "high" | "medium" | "low" | "info";
  cvss?: number;
  cwe?: string[];
  references?: string[];
  affectedComponent?: string;
  location?: {
    file: string;
    line: number;
    column: number;
  };
  remediation?: string;
}

export interface ScanResult {
  scanType: ScanType;
  target: string;
  timestamp: string;
  vulnerabilities: VulnerabilityResult[];
  summary: {
    total: number;
    critical: number;
    high: number;
    medium: number;
    low: number;
    info: number;
  };
  metadata: {
    scanner: string;
    version: string;
    duration: number;
  };
}

export class VulnerabilityScanner {
  async scan(
    target: string,
    scanType: ScanType,
    outputFormat: "json" | "sarif" | "table" = "json"
  ): Promise<ScanResult> {
    const startTime = Date.now();
    
    switch (scanType) {
      case "sca":
        return await this.runSCAScann(target, outputFormat, startTime);
      case "sast":
        return await this.runSASTScan(target, outputFormat, startTime);
      case "secrets":
        return await this.runSecretsScann(target, outputFormat, startTime);
      case "iac":
        return await this.runIACScan(target, outputFormat, startTime);
      case "container":
        return await this.runContainerScan(target, outputFormat, startTime);
      default:
        throw new Error(`Unsupported scan type: ${scanType}`);
    }
  }

  private async runSCAScann(target: string, outputFormat: string, startTime: number): Promise<ScanResult> {
    // Software Composition Analysis using multiple tools
    const vulnerabilities: VulnerabilityResult[] = [];

    try {
      // Try Snyk first
      const snykResult = await this.runSnykSCA(target);
      vulnerabilities.push(...snykResult);
    } catch (error) {
      console.warn("Snyk SCA failed:", error);
    }

    try {
      // Try npm audit as fallback
      const npmAuditResult = await this.runNpmAudit(target);
      vulnerabilities.push(...npmAuditResult);
    } catch (error) {
      console.warn("npm audit failed:", error);
    }

    return this.buildScanResult("sca", target, vulnerabilities, "SCA Scanner", startTime);
  }

  private async runSASTScan(target: string, outputFormat: string, startTime: number): Promise<ScanResult> {
    // Static Application Security Testing
    const vulnerabilities: VulnerabilityResult[] = [];

    try {
      // Try Snyk Code
      const snykCodeResult = await this.runSnykCode(target);
      vulnerabilities.push(...snykCodeResult);
    } catch (error) {
      console.warn("Snyk Code failed:", error);
    }

    try {
      // Try ESLint security plugin as fallback
      const eslintResult = await this.runESLintSecurity(target);
      vulnerabilities.push(...eslintResult);
    } catch (error) {
      console.warn("ESLint security scan failed:", error);
    }

    return this.buildScanResult("sast", target, vulnerabilities, "SAST Scanner", startTime);
  }

  private async runSecretsScann(target: string, outputFormat: string, startTime: number): Promise<ScanResult> {
    // Secrets scanning
    const vulnerabilities: VulnerabilityResult[] = [];

    try {
      // Custom secrets scanner
      const secretsResult = await this.runCustomSecretsScanner(target);
      vulnerabilities.push(...secretsResult);
    } catch (error) {
      console.warn("Secrets scan failed:", error);
    }

    return this.buildScanResult("secrets", target, vulnerabilities, "Secrets Scanner", startTime);
  }

  private async runIACScan(target: string, outputFormat: string, startTime: number): Promise<ScanResult> {
    // Infrastructure as Code scanning
    const vulnerabilities: VulnerabilityResult[] = [];

    try {
      // Scan for common IaC misconfigurations
      const iacResult = await this.runIACAnalysis(target);
      vulnerabilities.push(...iacResult);
    } catch (error) {
      console.warn("IaC scan failed:", error);
    }

    return this.buildScanResult("iac", target, vulnerabilities, "IaC Scanner", startTime);
  }

  private async runContainerScan(target: string, outputFormat: string, startTime: number): Promise<ScanResult> {
    // Container security scanning
    const vulnerabilities: VulnerabilityResult[] = [];

    try {
      // Try Snyk container scan
      const result = await execa("snyk", ["container", "test", target, "--json"], { reject: false });
      if (result.stdout) {
        const data = JSON.parse(result.stdout);
        vulnerabilities.push(...this.parseSnykContainerResults(data));
      }
    } catch (error) {
      console.warn("Container scan failed:", error);
    }

    return this.buildScanResult("container", target, vulnerabilities, "Container Scanner", startTime);
  }

  private async runSnykSCA(target: string): Promise<VulnerabilityResult[]> {
    const result = await execa("snyk", ["test", target, "--json"], { reject: false });
    if (result.stdout) {
      const data = JSON.parse(result.stdout);
      return this.parseSnykResults(data);
    }
    return [];
  }

  private async runNpmAudit(target: string): Promise<VulnerabilityResult[]> {
    const result = await execa("npm", ["audit", "--json"], { cwd: target, reject: false });
    if (result.stdout) {
      const data = JSON.parse(result.stdout);
      return this.parseNpmAuditResults(data);
    }
    return [];
  }

  private async runSnykCode(target: string): Promise<VulnerabilityResult[]> {
    const result = await execa("snyk", ["code", "test", target, "--json"], { reject: false });
    if (result.stdout) {
      const data = JSON.parse(result.stdout);
      return this.parseSnykCodeResults(data);
    }
    return [];
  }

  private async runESLintSecurity(target: string): Promise<VulnerabilityResult[]> {
    try {
      const result = await execa("npx", ["eslint", target, "--format", "json", "--ext", ".js,.ts"], { reject: false });
      if (result.stdout) {
        const data = JSON.parse(result.stdout);
        return this.parseESLintResults(data);
      }
    } catch (error) {
      // ESLint might not be configured, that's okay
    }
    return [];
  }

  private async runCustomSecretsScanner(target: string): Promise<VulnerabilityResult[]> {
    const vulnerabilities: VulnerabilityResult[] = [];
    
    if (!existsSync(target)) {
      return vulnerabilities;
    }

    const secretPatterns = {
      "aws-access-key": /AKIA[0-9A-Z]{16}/g,
      "github-token": /ghp_[a-zA-Z0-9]{36}/g,
      "api-key": /[aA][pP][iI][_]?[kK][eE][yY].*['"]['"]([0-9a-zA-Z]+)['"]['"]]/g,
      "password": /[pP][aA][sS][sS][wW][oO][rR][dD].*['"]['"]([^'"]+)['"]['"]]/g,
      "private-key": /-----BEGIN [A-Z ]+PRIVATE KEY-----/g,
    };

    try {
      const content = await readFile(target, "utf-8");
      const lines = content.split("\n");

      for (const [secretType, pattern] of Object.entries(secretPatterns)) {
        for (let lineNum = 0; lineNum < lines.length; lineNum++) {
          const line = lines[lineNum];
          const matches = Array.from(line.matchAll(pattern));
          
          for (const match of matches) {
            vulnerabilities.push({
              id: `secret-${secretType}-${lineNum}`,
              title: `Hardcoded ${secretType} detected`,
              description: `A potential ${secretType} was found in the code`,
              severity: "high",
              location: {
                file: target,
                line: lineNum + 1,
                column: match.index || 0,
              },
              remediation: "Remove hardcoded secrets and use environment variables or secure key management",
            });
          }
        }
      }
    } catch (error) {
      console.warn("Failed to scan for secrets:", error);
    }

    return vulnerabilities;
  }

  private async runIACAnalysis(target: string): Promise<VulnerabilityResult[]> {
    const vulnerabilities: VulnerabilityResult[] = [];
    
    // Look for common IaC files and misconfigurations
    const iacPatterns = {
      "docker-root-user": /USER\s+root/gi,
      "exposed-port": /EXPOSE\s+22|EXPOSE\s+3389/gi,
      "insecure-protocol": /http:\/\//gi,
    };

    try {
      if (target.endsWith("Dockerfile") || target.includes("docker")) {
        const content = await readFile(target, "utf-8");
        const lines = content.split("\n");

        for (const [ruleId, pattern] of Object.entries(iacPatterns)) {
          for (let lineNum = 0; lineNum < lines.length; lineNum++) {
            const line = lines[lineNum];
            if (pattern.test(line)) {
              vulnerabilities.push({
                id: `iac-${ruleId}-${lineNum}`,
                title: `IaC misconfiguration: ${ruleId}`,
                description: `Potential security issue in infrastructure configuration`,
                severity: "medium",
                location: {
                  file: target,
                  line: lineNum + 1,
                  column: 0,
                },
                remediation: "Review and fix the infrastructure configuration",
              });
            }
          }
        }
      }
    } catch (error) {
      console.warn("IaC analysis failed:", error);
    }

    return vulnerabilities;
  }

  private parseSnykResults(data: any): VulnerabilityResult[] {
    const vulnerabilities: VulnerabilityResult[] = [];
    
    if (data.vulnerabilities) {
      for (const vuln of data.vulnerabilities) {
        vulnerabilities.push({
          id: vuln.id,
          title: vuln.title,
          description: vuln.description || "",
          severity: vuln.severity,
          cvss: vuln.cvssScore,
          affectedComponent: vuln.packageName,
          references: vuln.references || [],
          remediation: vuln.upgradePath?.join(" -> ") || "No fix available",
        });
      }
    }

    return vulnerabilities;
  }

  private parseSnykCodeResults(data: any): VulnerabilityResult[] {
    const vulnerabilities: VulnerabilityResult[] = [];
    
    if (data.runs && data.runs[0] && data.runs[0].results) {
      for (const result of data.runs[0].results) {
        vulnerabilities.push({
          id: result.ruleId,
          title: result.message.text,
          description: result.message.text,
          severity: this.mapSnykSeverity(result.level),
          location: {
            file: result.locations[0]?.physicalLocation?.artifactLocation?.uri || "",
            line: result.locations[0]?.physicalLocation?.region?.startLine || 0,
            column: result.locations[0]?.physicalLocation?.region?.startColumn || 0,
          },
          remediation: "Review the code and apply recommended fixes",
        });
      }
    }

    return vulnerabilities;
  }

  private parseSnykContainerResults(data: any): VulnerabilityResult[] {
    const vulnerabilities: VulnerabilityResult[] = [];
    
    if (data.vulnerabilities) {
      for (const vuln of data.vulnerabilities) {
        vulnerabilities.push({
          id: vuln.id,
          title: vuln.title,
          description: vuln.description || "",
          severity: vuln.severity,
          cvss: vuln.cvssScore,
          affectedComponent: vuln.packageName,
          remediation: "Update the base image or package",
        });
      }
    }

    return vulnerabilities;
  }

  private parseNpmAuditResults(data: any): VulnerabilityResult[] {
    const vulnerabilities: VulnerabilityResult[] = [];
    
    if (data.vulnerabilities) {
      for (const [packageName, vuln] of Object.entries(data.vulnerabilities as Record<string, any>)) {
        vulnerabilities.push({
          id: `npm-audit-${packageName}`,
          title: vuln.title || `Vulnerability in ${packageName}`,
          description: vuln.overview || "",
          severity: vuln.severity,
          affectedComponent: packageName,
          references: vuln.references ? [vuln.references] : [],
          remediation: vuln.recommendation || "Update the package",
        });
      }
    }

    return vulnerabilities;
  }

  private parseESLintResults(data: any[]): VulnerabilityResult[] {
    const vulnerabilities: VulnerabilityResult[] = [];
    
    for (const fileResult of data) {
      for (const message of fileResult.messages) {
        if (message.ruleId && message.ruleId.includes("security")) {
          vulnerabilities.push({
            id: `eslint-${message.ruleId}`,
            title: message.message,
            description: message.message,
            severity: message.severity === 2 ? "high" : "medium",
            location: {
              file: fileResult.filePath,
              line: message.line,
              column: message.column,
            },
            remediation: "Fix the security issue according to ESLint recommendations",
          });
        }
      }
    }

    return vulnerabilities;
  }

  private mapSnykSeverity(level: string): "critical" | "high" | "medium" | "low" | "info" {
    switch (level?.toLowerCase()) {
      case "error": return "high";
      case "warning": return "medium";
      case "note": return "low";
      default: return "info";
    }
  }

  private buildScanResult(
    scanType: ScanType,
    target: string,
    vulnerabilities: VulnerabilityResult[],
    scanner: string,
    startTime: number
  ): ScanResult {
    const summary = {
      total: vulnerabilities.length,
      critical: vulnerabilities.filter(v => v.severity === "critical").length,
      high: vulnerabilities.filter(v => v.severity === "high").length,
      medium: vulnerabilities.filter(v => v.severity === "medium").length,
      low: vulnerabilities.filter(v => v.severity === "low").length,
      info: vulnerabilities.filter(v => v.severity === "info").length,
    };

    return {
      scanType,
      target,
      timestamp: new Date().toISOString(),
      vulnerabilities,
      summary,
      metadata: {
        scanner,
        version: "1.0.0",
        duration: Date.now() - startTime,
      },
    };
  }
}
